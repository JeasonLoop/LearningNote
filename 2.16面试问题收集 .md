2.16面试 - 华漫科技



##### 1.JS缓存

①解决缓存问题

有时候在更改js文件后，页面并没有及时显示出来，可能由于修改的文件不对，或者存在缓存问题。

面对的缓存问题有两个：

一是页面引入的js文件缓存。

二是js请求后台的缓存。

解决方法：

对于第一种情况，有两种处理方式：1、可以在页面引入的js文件后面增加日趋，如果不经常改动的文件，可以在每次改动后修改后缀。

```js
<script type="text/javascript" src="scripts/jquery-1.5.2.min.js?version=1"></script>
```

2、修改js文件的名字，如

```js
<script type="text/javascript" src="scripts/jquery.js"></script>
```

对于第二种情况，一般的处理方式是在请求的路径后面加上毫秒值，这样每次请求的路径都不一样，但是对于后台来说都是一样的，用来欺骗浏览器，进行实时请求，不调用浏览器缓存

②js本地缓存的几种方法

*A.session*

**临时的会话存储**，只要当前的会话窗口未关闭，存储的信息就不会丢失，即便刷新了页面或者在编辑器中更改了代码，存储的会话信息也不会丢失。

*B.local*

是一种如果你不主动去清除，会一直将数据存储在客户端的储存方式，即使关闭了浏览器，下次打开的时候仍然可以看到之前存储的未主动清除的数据（即便是

杀毒软件或者浏览器自带的清除功能，也不能将localStorage存储的数据清除掉）.

*C.cookie*

cookie本地存储的数据会被发送到服务器（所以建议在服务器环境下使用cookie）；

跨域访问问题；浪费带宽等等；

在js的脚本中，cookie实际上是document的一个字符属性，当你读取cookie的值时，得到的是一个字符串，里面的是当前web存放的所有的cookie的name,value,除此之外，

每一个cookie除了有name，value，还有其他四个属性：expires过期时间,path路径，domain域以及secure安全等。

 cookie中存储的数据，如果没有设置有效期的话，浏览器关闭的时候就会被清空（并非关系选项卡）

cookie的区分是以域名的方式。

cookie的用法：以键值对的方式来存储数据（key：value形式）,一个域名下能存储的cookie个数是不同的，具体的看浏览器的支持性了



##### 2.vue生命周期有哪些 具体可以干啥✔ 

##### 3.vue响应原理✔

##### 4.vue双向绑定 ✔

##### 5.元素实现水平垂直居中✔

**①父元素设置高度等于行高**

只在父元素高度已知，并且子元素是文本的情况下适用。

![img](https://images2015.cnblogs.com/blog/781464/201705/781464-20170517132829619-445441590.png)

**②子元素相对定位**

这种方法只在子元素宽高已知的情况下适用。

![img](https://images2015.cnblogs.com/blog/781464/201705/781464-20170511143849832-2096859298.png)

**③子元素相对于父元素绝对定位，并配合使用负值的 margin**

最常见的方法，这种方法只能在子元素宽高已知的情况下使用。

![img](https://images2015.cnblogs.com/blog/781464/201705/781464-20170511140824332-1697957496.png)

**④子元素相对父元素绝对定位，并使用 calc() 计算属性**

思想同上一种方法，只不过用计算属性替代了偏移量和 margin

![img](https://images2015.cnblogs.com/blog/781464/201705/781464-20170511142701660-117442223.png)

 **⑤子元素相对于父元素绝对定位(偏移量都为0)，子元素设置margin:auto;**

这种方式同样只在子元素高宽已知的情况下使用。

 ![img](https://images2015.cnblogs.com/blog/781464/201705/781464-20170511141228941-220670851.png)



**⑥父元素 display:flex; 子元素 margin:auto;**

最简单的方式，子元素宽高已知未知的情况都适用。　

![img](https://images2015.cnblogs.com/blog/781464/201705/781464-20170511140853160-1473535630.png) 

##### 6.CSS布局✔

##### 7.浏览器跨域

**①什么是跨域问题**

在页面中使用js访问其他网站的数据时，就会出现跨域问题，比如在网站中使用ajax请求其他网站的天气、快递或者其他数据接口时，以及hybrid app中请求数据，浏览器会提 示一下错误：

XMLHttpRequest cannot load http://你请求的域名. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://当前页的域名' is therefore not allowed access.

**②为什么会出现跨域问题**

因为浏览器收到同源策略的限制，当前域名的js只能读取同域下的窗口属性。

同源策略： 不同的域名, 不同端口, 不同的协议不允许共享资源的， 保障浏览器安全。

同源策略时针对浏览器设置的门槛。如果绕过浏览就能实现跨域，所以说早期的跨域都是打着安全路数的擦边球，都可以认为是 hack 处理。

③解决跨域的方法

A.******jsonp 跨域方法**

我们提供一个 script 标签. 请求页面中的数据, 同时传入一个回调函数的名字. 服务器端得到名字后, 拼接函数执行格式的字符串. 发送回浏览器. script 在下载代码以后并执行, 执行的就是这个函数调用形式的字符串, 因此就将本地函数调用了.同时拿到了从服务器端得到的数据

B.**window.name**

window对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给 window.name，iframe加载完成之后，页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出window.name的值了。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。





##### 8.JS 的promise对象

ECMAscript 6 原生提供了 Promise 对象。

*Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息*

⚪Promise对象的特点

①对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：

- pending: 初始状态，不是成功或失败状态。

- fulfilled: 意味着操作成功完成。

- rejected: 意味着操作失败

  只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态

②优缺点

有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。

Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

*-----自己的理解，有点像进程的三状态模型，就绪态，执行态和阻塞态（对应等待，完成，拒绝）*



##### 9.js中的同步异步

